<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="robots" content="noindex, nofollow">
<title>Motion Diff Visualization</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #fafafa; }
  header { text-align: center; margin-bottom: 20px; }
  select { padding: 6px 10px; font-size: 16px; }
  
  .container {
    display: flex; 
    justify-content: center; 
    align-items: flex-start; 
    gap: 20px;
  }
  .column { width: 48%; text-align: center; }
  .col-title {
    font-weight: bold;
    font-size: 18px;
    color: #222;
    margin-bottom: 8px;
  }
  video { width: 100%; border-radius: 8px; background: #000; }
  .caption { font-style: italic; color: #555; margin-top: 6px; }

  .text-section {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
    text-align: left;
    margin-top: 6px;
    width: 100%;
  }
  #overlap {
    width: 100%;
    border-radius: 8px;
    background: #000;
  }
  .text-box {
    background: rgba(255,255,255,0.85); 
    padding: 6px 12px;
    border-radius: 8px;
    font-weight: 500;
    box-shadow: 0 1px 4px rgba(0,0,0,0.10);
    width: 100%; /* 填满父容器 */
    box-sizing: border-box; /* 确保 padding 不会撑破宽度 */
  }
    /* Style for metrics display */
    .metrics-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.9em;
      margin-top: 5px;
    }
    .metric-item {
      background: #f0f0f0;
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    .metric-label {
      font-weight: bold;
      color: #666;
    }
    .metric-value {
      font-family: monospace;
      color: #000;
    }
  </style>
</head>
<body>
  <header>
    <h2>Motion Diff Visualization</h2>
    <div style="margin-bottom: 10px;">
      <label for="datasetSelect">Select Dataset:</label>
      <select id="datasetSelect" onchange="changeDataset(this.value)">
        <option value="motionfix">MotionFix</option>
        <option value="stance">Stance</option>
      </select>
    </div>
    <label for="dataSelect">Select data ID:</label>
    <select id="dataSelect" onchange="loadData(this.value)"></select>
  </header>

  <div class="container">
    <!-- 左列：overlap 视频 -->
    <div class="column">
      <div class="col-title">Overlap Comparison</div>
      <div style="font-weight: bold; margin-bottom: 5px; font-size: 16px;">
        <span style="color: red;">Source</span> to <span style="color: green;">Target</span>
      </div>
      <video id="overlap" autoplay muted loop controls></video>
    </div>

    <!-- 右列：文本（从上到下） -->
    <div class="column">
      <div class="col-title">Text Comparison</div>
      <div id="textSection" class="text-section"></div>
    </div>
  </div>

  <script>
    let DATA = {};
    let STANCE_DATA_MAP = {}; 
    let DATASET_METRICS = {}; // Store dataset-level metrics here
    let CURRENT_DS = 'motionfix';

    // Initialize
    changeDataset('motionfix');

    function updateTextSection(ds) {
      const mainContainer = document.getElementById('textSection');
      mainContainer.innerHTML = ''; 

      // 1. Per-sample Text & Metrics
      if (ds === 'motionfix') {
        mainContainer.appendChild(createTextBox('GT: ', 'text1', 'blue'));
        
        mainContainer.appendChild(createTextBox('DEMO: ', 'text2'));
        mainContainer.appendChild(createMetricsBox('DEMO Metrics:', 'metrics_base')); 

        // mainContainer.appendChild(createTextBox('Ours:', 'text3', 'green'));
        // mainContainer.appendChild(createMetricsBox('Ours Metrics:', 'metrics_ours')); 

        mainContainer.appendChild(createTextBox('Ours STMC: ', 'text6', 'green'));
        mainContainer.appendChild(createMetricsBox('Ours STMC Metrics:', 'metrics_stmc'));


        mainContainer.appendChild(createTextBox('Ours MARDM: ', 'text4', 'green'));
        mainContainer.appendChild(createMetricsBox('Ours MARDM Metrics:', 'metrics_mardm'));

        // mainContainer.appendChild(createTextBox('Ours simple_h3d:', 'text5', 'green'));
        // mainContainer.appendChild(createMetricsBox('Ours simple_h3d Metrics:', 'metrics_simple_h3d'));

      } else {
        mainContainer.appendChild(createTextBox('GT:', 'text1', 'red')); 
        
        mainContainer.appendChild(createTextBox('DEMO (inf):', 'text2'));
        mainContainer.appendChild(createMetricsBox('DEMO Metrics:', 'metrics_base')); 
        
        mainContainer.appendChild(createTextBox('Ours (inf):', 'text3', 'green')); 
        mainContainer.appendChild(createMetricsBox('Ours Metrics:', 'metrics_ours')); 
      }
      
      // 2. Dataset Metrics
      const dsBox = document.createElement('div');
      dsBox.className = 'text-box';
      dsBox.style.marginTop = '20px';
      dsBox.style.border = '1px solid #ddd';
      
      const dsTitle = document.createElement('div');
      dsTitle.className = 'label';
      dsTitle.textContent = 'Dataset Average Metrics';
      
      const dsContent = document.createElement('div');
      dsContent.id = 'datasetMetrics';
      
      dsBox.appendChild(dsTitle);
      dsBox.appendChild(dsContent);
      mainContainer.appendChild(dsBox);
      
      renderDatasetMetrics(); // Call render
    }
    
    function renderDatasetMetrics() {
        const container = document.getElementById('datasetMetrics');
        if(!container) return;
        
        const metrics = DATASET_METRICS[CURRENT_DS];
        if (!metrics) {
            container.innerHTML = "<em>Not available</em>";
            return;
        }
        
        container.innerHTML = "";
        
        // --- Calculate Best Dataset Metrics ---
        const bestDatasetMetrics = {};
        const metricKeys = ["BERT", "BLEURT", "CIDEr", "METEOR"];
        // We only compare Demo, STMC, MARDM
        const compareKeys = ["demo", "stmc", "mardm"];

        metricKeys.forEach(mKey => {
            let maxVal = -Infinity;
            compareKeys.forEach(model => {
                const modelMetrics = metrics[model];
                if (modelMetrics && modelMetrics[mKey] !== undefined) {
                    const val = Number(modelMetrics[mKey]);
                    if (val > maxVal) maxVal = val;
                }
            });
            if (maxVal !== -Infinity) bestDatasetMetrics[mKey] = maxVal;
        });
        // --------------------------------------

        // Helper to render a row
        const renderRow = (label, data) => {
            if(!data) return;
            const row = document.createElement('div');
            row.style.marginBottom = "5px";
            row.innerHTML = `<div style="font-weight:bold; color:#555; font-size:0.9em;">${label}</div>`;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'metrics-container';
            
            const keys = ["BERT", "BLEURT", "CIDEr", "METEOR"];
            keys.forEach(key => {
                if (data[key] !== undefined) {
                    const item = document.createElement('div');
                    item.className = 'metric-item';
                    const img = document.createElement('span');
                    const lbl = document.createElement('span');
                    lbl.className = 'metric-label';
                    lbl.textContent = key + ": ";
                    
                    const val = document.createElement('span');
                    val.className = 'metric-value';
                    const numVal = Number(data[key]);
                    val.textContent = (numVal * 100).toFixed(4); // Scale for display * 100
                    
                    // HIGHLIGHT LOGIC
                    if (bestDatasetMetrics[key] !== undefined) {
                        if (Math.abs(numVal - bestDatasetMetrics[key]) < 0.0001) {
                             val.style.fontWeight = "bold";
                             val.style.color = "#2e7d32"; // Dark green
                             val.style.backgroundColor = "#e8f5e9";
                             val.style.padding = "0 4px";
                             val.style.borderRadius = "4px";
                        }
                    }

                    item.appendChild(lbl);
                    item.appendChild(val);
                    wrapper.appendChild(item);
                }
            });
            row.appendChild(wrapper);
            container.appendChild(row);
        };
        
        renderRow("DEMO (Avg):", metrics.demo);
        /* renderRow("Ours (Avg):", metrics.ours); */
        if (metrics.stmc) renderRow("Ours STMC (Avg):", metrics.stmc);
        if (metrics.mardm) renderRow("Ours MARDM (Avg):", metrics.mardm);
        // if (metrics.simple_h3d) renderRow("Simple H3D (Avg):", metrics.simple_h3d);
    }

    function createTextBox(label, id, color) {
       const box = document.createElement('div');
       box.className = 'text-box';
       
       const labelSpan = document.createElement('span');
       labelSpan.className = 'label';
       labelSpan.textContent = label;
       labelSpan.style.fontWeight = 'bold'; // Increased weight
       labelSpan.style.marginRight = '8px'; // Add some spacing

       if (color) labelSpan.style.color = color;
       
       const textSpan = document.createElement('span');
       textSpan.id = id;
       
       box.appendChild(labelSpan);
       box.appendChild(textSpan);
       return box;
    }
    
    function createMetricsBox(label, id) {
        const box = document.createElement('div');
        box.className = 'text-box';
        // Distinct style
        box.style.backgroundColor = '#f8f9fa';
        box.style.fontSize = '0.9em';
        box.style.marginBottom = '8px';
        
        const labelSpan = document.createElement('span');
        labelSpan.className = 'label';
        labelSpan.textContent = label;
        labelSpan.style.color = '#555';
        labelSpan.style.fontWeight = 'bold'; // Increased weight
        
        const contentDiv = document.createElement('div');
        contentDiv.id = id;
        
        box.appendChild(labelSpan);
        box.appendChild(contentDiv);
        return box;
    }

    function changeDataset(ds) {
      CURRENT_DS = ds;
      updateTextSection(ds); // Update text UI structure based on dataset
      const select = document.getElementById('dataSelect');
      const dataLabel = document.querySelector('label[for="dataSelect"]'); // Assuming there is one

      // Clear current data while loading
      select.innerHTML = '<option>Loading...</option>';
      loadData(null); 

      if (ds === 'motionfix') {
        fetch('data.json')
          .then(r => r.json())
          .then(json => {
            // Check for Dataset Metrics
            if (json['DATASET_METRICS']) {
                DATASET_METRICS['motionfix'] = json['DATASET_METRICS'];
                delete json['DATASET_METRICS']; // Remove from main data
            }
            
            DATA = json;
            populateSelect(Object.keys(DATA));
            
            // Render metrics now that data is loaded
            renderDatasetMetrics();
          })
          .catch(err => {
             console.error(err);
             select.innerHTML = '<option>Error loading data.json</option>';
          });
      } else if (ds === 'stance') {
        Promise.all([
          fetch('stance/adjustment_all_map.json').then(r => r.json()),
          fetch('stance/adjustments.json').then(r => r.json()),
          fetch('stance/adjust_test.json').then(r => r.json()),
          fetch('stance/data.json').then(r => r.json()).catch(() => ({})) // Load extra data, default to empty if missing
        ]).then(([allMap, adjustments, testIds, extraData]) => {
          
          // Check for Dataset Metrics in stance/data.json (extraData)
          if (extraData && extraData['DATASET_METRICS']) {
              DATASET_METRICS['stance'] = extraData['DATASET_METRICS'];
              delete extraData['DATASET_METRICS'];
          }
          
          STANCE_DATA_MAP = {};
          
          const filenameToId = allMap; // The file provides Filename -> ID
          const idToFilename = {};
          
          // Build reverse map
          // We need mapping from ID in adjust_test.json -> filename
          // adjustment_all_map.json format: { "filename.pkl": "ID" }
          // So reverse map is { "ID": "filename.pkl" }
          
          for (const [file, id] of Object.entries(filenameToId)) {
             idToFilename[String(id).trim()] = file.trim();
          }

          const validIds = testIds.map(String).map(s => s.trim()).filter(id => {
             const has = Object.prototype.hasOwnProperty.call(idToFilename, id);
             if (!has) console.warn(`ID ${id} from test set not found in map`);
             return has;
          });
          
          console.log(`Found ${validIds.length} valid IDs out of ${testIds.length} test IDs`);

          // Build Data Map
          STANCE_DATA_MAP = {}; 
          validIds.forEach(id => {
            const fname = idToFilename[id];
            // fname e.g. "paired_data_seed0_15_batch0_id108.pkl"
            const stem = fname.replace('.pkl', '');
            
            // Construct video path
            const videoPath = `stance/comparison_renders/compare_${stem}.mp4`;
            
            // Construct text
            // text1 mainly comes from adjustments structure as Source/Demo
            let textContent = (adjustments[id] && adjustments[id].text) ? adjustments[id].text : "No text found for ID " + id;
            if (adjustments[id] && adjustments[id].body_part) {
                textContent += ` (Body Part: ${adjustments[id].body_part})`;
            }

            // Retrieve extra texts from stance/data.json if available
            // Assumed format: { "ID": { "text2": "...", "text7": "..." } }
            const extra = (extraData && extraData[id]) ? extraData[id] : {};

            STANCE_DATA_MAP[id] = {
              overlap: videoPath,
              text1: textContent,
              text2: extra.text2 || "", 
              text3: extra.text3 || "", 
              text4: extra.text4 || "", 
              text5: extra.text5 || "", 
              text6: extra.text6 || "", 
              text7: extra.text7 || "",
              metrics: extra.metrics || null // Also map metrics if present
            };
          });
          
          if (validIds.length === 0) {
            console.error("No valid IDs found for Stance data!");
             select.innerHTML = '<option>No valid IDs found</option>';
             return;
          }

          populateSelect(validIds); 
          renderDatasetMetrics(); // Render after loading
        }).catch(err => {
          console.error(err);
          select.innerHTML = '<option>Error loading Stance data</option>';
        });
      }
    }

    function populateSelect(keys) {
      const select = document.getElementById('dataSelect');
      select.innerHTML = '';
      
      if (!keys || keys.length === 0) {
        select.innerHTML = '<option>No Data Found</option>';
        return;
      }

      keys.forEach((key) => {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = key;
        select.appendChild(opt);
      });
      
      select.value = keys[0];
      loadData(keys[0]);
    }

    function renderMetrics(containerId, metrics, bestMetrics) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = ""; // Clear existing
        if (!metrics) {
            container.textContent = "N/A";
            return;
        }

        const wrapper = document.createElement('div');
        wrapper.className = 'metrics-container';
        
        const keys = ["BERT", "BLEURT", "CIDEr", "METEOR"];
        keys.forEach(key => {
            if (metrics[key] !== undefined) {
                const item = document.createElement('div');
                item.className = 'metric-item';
                
                const lbl = document.createElement('span');
                lbl.className = 'metric-label';
                lbl.textContent = key + ": ";
                
                const val = document.createElement('span');
                val.className = 'metric-value';
                const numVal = Number(metrics[key]);
                val.textContent = (numVal * 100).toFixed(4);
                
                // Highlight if best
                if (bestMetrics && bestMetrics[key] !== undefined) {
                    // Check if current value is close to max (allow tiny float diff)
                    if (Math.abs(numVal - bestMetrics[key]) < 0.000001) {
                         val.style.fontWeight = "bold";
                         val.style.color = "#2e7d32"; // Dark green
                         val.style.backgroundColor = "#e8f5e9"; // Light green bg
                         val.style.padding = "0 4px";
                         val.style.borderRadius = "4px";
                    }
                }
                
                item.appendChild(lbl);
                item.appendChild(val);
                wrapper.appendChild(item);
            }
        });
        container.appendChild(wrapper);
    }
    
    function loadData(id) {
      if (!id) {
         const ov = document.getElementById("overlap");
         if(ov) { ov.src=""; ov.load(); }
         for(let i=1; i<=7; i++) {
             const t = document.getElementById("text"+i)
             if(t) t.textContent = "";
         }
         return;
      }
      
      let d = null;
      if (CURRENT_DS === 'motionfix') {
        d = DATA[id];
      } else {
        d = STANCE_DATA_MAP[id];
      }
      
      if (!d) return;

      const vids = [
        { el: "overlap", src: d.overlap }
      ];

      vids.forEach(v => {
        const elem = document.getElementById(v.el);
        if(!elem) return;
        
        console.log(`Loading video for ${v.el}: ${v.src}`); // Debugging
        
        elem.pause();
        elem.src = v.src || "";
        elem.loop = true;
        elem.autoplay = true;
        elem.muted = true;
        
        elem.onerror = (e) => {
            console.error(`Error loading video ${v.src}:`, elem.error);
            // alert(`Failed to load video: ${v.src}\nCheck console for details.`);
        };
        
        elem.load();
        elem.onloadeddata = () => {
          console.log(`Video loaded successfully: ${v.src}`);
          elem.play().catch(e => console.warn("Auto-play failed:", e));
        };
      });

      if(document.getElementById("text1")) document.getElementById("text1").textContent = d.text1 || "";
      if(document.getElementById("text2")) document.getElementById("text2").textContent = d.text2 || "";
      if(document.getElementById("text3")) document.getElementById("text3").textContent = d.text3 || "";
      if(document.getElementById("text4")) document.getElementById("text4").textContent = d.text4 || "";
      if(document.getElementById("text5")) document.getElementById("text5").textContent = d.text5 || "";
      if(document.getElementById("text6")) document.getElementById("text6").textContent = d.text6 || "";
      // Calculate Best Metrics for Demo, MARDM, STMC
      const m = d.metrics || {};
      const inputs = [m.demo, m.mardm, m.stmc].filter(x => x);
      const bestMetrics = {};
      ["BERT", "BLEURT", "CIDEr", "METEOR"].forEach(key => {
          let maxVal = -Infinity;
          inputs.forEach(obj => {
              if (obj[key] !== undefined) {
                  const val = Number(obj[key]);
                  if (val > maxVal) maxVal = val;
              }
          });
          if (maxVal !== -Infinity) bestMetrics[key] = maxVal;
      });

      // Load metrics if available
      renderMetrics("metrics_base", m.demo, bestMetrics); 
      // renderMetrics("metrics_ours", m.ours, bestMetrics);
      renderMetrics("metrics_mardm", m.mardm, bestMetrics);
      // renderMetrics("metrics_simple_h3d", m.simple_h3d, bestMetrics);
      renderMetrics("metrics_stmc", m.stmc, bestMetrics);
    
    }
  </script>
</body>
</html>